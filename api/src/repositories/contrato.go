package repositories

import (
	"api/api/src/models"
	"database/sql"
	"fmt"
	"log"
)

type Contrato struct {
	db *sql.DB
}

func NovoRepositorioContrato(db *sql.DB) *Contrato {
	return &Contrato{db}
}

func (repositorio Contrato) BuscarContrato(contratoNumero uint64)([]models.Contrato, error){
	query := `SELECT 'TITULAR' AS TIPO, C.IDCLIENTE,C.CONTRATO,C.NOME, C.NOME AS TITULAR,C.CPF_CNPJ,
		(SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
		WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
		ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC) AS ULT_MES_REF_PG,
		CASE 
			WHEN C.SITUACAO = 4 THEN 0
			WHEN C.DATA_CONTRATO >= DATEADD(1 - EXTRACT(DAY FROM CURRENT_DATE) DAY TO CURRENT_DATE ) THEN 0
			ELSE
				((CURRENT_DATE) - (SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
				WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
				ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC))
		END AS DIAS_ATRASO,
		CASE
			WHEN C.SITUACAO = 4 THEN 'ATIVO'
			WHEN C.DATA_CONTRATO >= DATEADD(1 - EXTRACT(DAY FROM CURRENT_DATE) DAY TO CURRENT_DATE ) THEN 'ATIVO'
			WHEN ((CURRENT_DATE) - (SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
		WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
		ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC)) < 90 THEN 'ATIVO'
		ELSE 'INATIVO'
		END AS STATUS
		FROM CLIENTE C
		WHERE C.CONTRATO = 60721
		AND ((C.SITUACAO =1) OR (C.SITUACAO =4))
		UNION
		SELECT  'DEPENDENTE' AS TIPO , C.IDCLIENTE,C.CONTRATO,D.NOME, C.NOME AS TITULAR, D.CPF AS CPF_CNPJ,
		(SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
		WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
		ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC) AS ULT_MES_REF_PG,
		CASE 
			WHEN C.SITUACAO = 4 THEN 0
			WHEN C.DATA_CONTRATO >= DATEADD(1 - EXTRACT(DAY FROM CURRENT_DATE) DAY TO CURRENT_DATE ) THEN 0
			ELSE
				((CURRENT_DATE) - (SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
				WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
				ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC))
		END AS DIAS_ATRASO,
		CASE
			WHEN C.SITUACAO = 4 THEN 'ATIVO'
			WHEN C.DATA_CONTRATO >= DATEADD(1 - EXTRACT(DAY FROM CURRENT_DATE) DAY TO CURRENT_DATE ) THEN 'ATIVO'
			WHEN ((CURRENT_DATE) - (SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
		WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
		ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC)) < 90 THEN 'ATIVO'
		ELSE 'INATIVO'
		END AS STATUS
		FROM DEPENDENTE D
		LEFT JOIN CLIENTE C ON C.IDCLIENTE=D.CLIENTE_ID
		WHERE C.CONTRATO = 60721
		AND D.SITUACAO=1
		AND D.DATA_FALECIMENTO IS NULL AND D.SITUACAO = 1 
		AND D.TIPO_DEPENDENTE = 1 
		AND ((C.SITUACAO =1) OR (C.SITUACAO =4))`

	linhas, erro := repositorio.db.Query(query);

	if erro != nil{
		fmt.Println(erro.Error())
		return nil, erro
	}

	defer linhas.Close()

	var contratos []models.Contrato

	for linhas.Next(){
		fmt.Println("ldkkdd")
		var contrato models.Contrato

		if erro := linhas.Scan(
			&contrato.Tipo,
			&contrato.Idcliente,
			&contrato.Contrato,
			&contrato.Nome,
			&contrato.Titular,
			&contrato.CpfCnpj,
			&contrato.UltMesRefPg,
			&contrato.DiasAtraso,
			&contrato.Status,
		); erro != nil{
			return nil, erro
		}

		
		log.Fatalln("aaa")

		contratos = append(contratos, contrato)
	}

	return contratos, nil
}