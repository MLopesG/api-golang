package repositories

import (
	"api/api/src/models"
	"database/sql"
	"fmt"
)

type Contrato struct {
	db *sql.DB
}

func NovoRepositorioContrato(db *sql.DB) *Contrato {
	return &Contrato{db}
}

func (repositorio Contrato) BuscarContrato(contratoNumero int64)([]models.Contrato, error){

	query :=  fmt.Sprintf(`SELECT 'TITULAR' AS TIPO, C.IDCLIENTE,C.CONTRATO,C.NOME, C.NOME AS TITULAR,C.CPF_CNPJ,
	(SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
	WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
	ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC) AS ULT_PG,
	CASE 
		WHEN C.SITUACAO = 4 THEN 0
		WHEN C.DATA_CONTRATO >= DATEADD(1 - EXTRACT(DAY FROM CURRENT_DATE) DAY TO CURRENT_DATE ) THEN 0
		ELSE
			((CURRENT_DATE) - (SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
			WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
			ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC))
	END AS DIAS_ATRASO,
	CASE
		WHEN C.SITUACAO = 4 THEN 'ATIVO'
		WHEN C.DATA_CONTRATO >= DATEADD(1 - EXTRACT(DAY FROM CURRENT_DATE) DAY TO CURRENT_DATE ) THEN 'ATIVO'
		WHEN ((CURRENT_DATE) - (SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
	WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
	ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC)) < 90 THEN 'ATIVO'
	ELSE 'INATIVO'
	END AS STATUS
	FROM CLIENTE C
	WHERE C.CONTRATO = '%d'
	AND ((C.SITUACAO =1) OR (C.SITUACAO =4))
	UNION
	SELECT  'DEPENDENTE' AS TIPO , C.IDCLIENTE,C.CONTRATO,D.NOME, C.NOME AS TITULAR, D.CPF AS CPF_CNPJ,
	(SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
	WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
	ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC) AS ULT_PG,
	CASE 
		WHEN C.SITUACAO = 4 THEN 0
		WHEN C.DATA_CONTRATO >= DATEADD(1 - EXTRACT(DAY FROM CURRENT_DATE) DAY TO CURRENT_DATE ) THEN 0
		ELSE
			((CURRENT_DATE) - (SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
			WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
			ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC))
	END AS DIAS_ATRASO,
	CASE
		WHEN C.SITUACAO = 4 THEN 'ATIVO'
		WHEN C.DATA_CONTRATO >= DATEADD(1 - EXTRACT(DAY FROM CURRENT_DATE) DAY TO CURRENT_DATE ) THEN 'ATIVO'
		WHEN ((CURRENT_DATE) - (SELECT FIRST(1) PC.DATA_VENCIMENTO FROM PARCELAS_CLIENTE PC
	WHERE PC.CLIENTE_ID=C.IDCLIENTE AND PC.DATA_PAGAMENTO IS NOT NULL
	ORDER BY PC.DATA_VENCIMENTO DESC , PC.DATA_PAGAMENTO DESC)) < 90 THEN 'ATIVO'
	ELSE 'INATIVO'
	END AS STATUS
	FROM DEPENDENTE D
	LEFT JOIN CLIENTE C ON C.IDCLIENTE=D.CLIENTE_ID
	WHERE C.CONTRATO = '%d'
	AND D.SITUACAO=1
	AND D.DATA_FALECIMENTO IS NULL AND D.SITUACAO = 1 
	AND D.TIPO_DEPENDENTE = 1 
	AND ((C.SITUACAO =1) OR (C.SITUACAO =4))`, uint64(contratoNumero), uint64(contratoNumero));

	linhas, erro := repositorio.db.Query(query);
	
	if erro != nil{
		fmt.Println(erro.Error())
		return nil, erro
	}

	defer linhas.Close()

	var contratos []models.Contrato

	for linhas.Next(){

		var contrato models.Contrato

		if erro := linhas.Scan(
			&contrato.Tipo,
			&contrato.Idcliente,
			&contrato.Contrato,
			&contrato.Nome,
			&contrato.Titular,
			&contrato.CpfCnpj,
			&contrato.UltPg,
			&contrato.DiasAtraso,
			&contrato.Status,
		); erro != nil{
			return nil, erro
		}

		contratos = append(contratos, contrato)
	}

	return contratos, nil
}